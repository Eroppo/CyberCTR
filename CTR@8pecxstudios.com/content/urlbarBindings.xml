<?xml version="1.0"?>

<!--
 Modified Firefox 48+ bindings offered in
 chrome://global/content/bindings/autocomplete.xml#autocomplete-rich-result-popup
 and
 chrome://browser/content/urlbarBindings.xml#urlbar-rich-result-popup
 to simulate pre-Fx48 look of location bars autocomplete popup.
 Remove all default comentets to reduce file size. 
-->

<!DOCTYPE bindings [
<!ENTITY % notificationDTD SYSTEM "chrome://global/locale/notification.dtd">
%notificationDTD;
<!ENTITY % browserDTD SYSTEM "chrome://browser/locale/browser.dtd">
%browserDTD;
<!ENTITY % brandDTD SYSTEM "chrome://branding/locale/brand.dtd">
%brandDTD;
]>

<bindings id="urlbarBindings" xmlns="http://www.mozilla.org/xbl"
          xmlns:html="http://www.w3.org/1999/xhtml"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="urlbar-rich-result-popup" extends="chrome://global/content/bindings/autocomplete.xml#autocomplete-rich-result-popup">

    <content ignorekeys="true" level="top" consumeoutsideclicks="never"
             aria-owns="richlistbox">
      <xul:hbox anonid="search-suggestions-notification"
                align="center"
                role="alert"
                aria-describedby="search-suggestions-notification-text">
        <xul:description flex="1">
          &urlbar.searchSuggestionsNotification.question;
          <xul:label id="search-suggestions-notification-learn-more"
                     class="text-link"
                     role="link"
                     value="&urlbar.searchSuggestionsNotification.learnMore;"
                     accesskey="&urlbar.searchSuggestionsNotification.learnMore.accesskey;"
                     onclick="document.getBindingParent(this).openSearchSuggestionsNotificationLearnMoreURL();"
                     control="search-suggestions-notification-learn-more"/>
        </xul:description>
        <xul:button anonid="search-suggestions-notification-disable"
                    label="&urlbar.searchSuggestionsNotification.disable;"
                    accesskey="&urlbar.searchSuggestionsNotification.disable.accesskey;"
                    onclick="document.getBindingParent(this).dismissSearchSuggestionsNotification(false);"/>
        <xul:button anonid="search-suggestions-notification-enable"
                    label="&urlbar.searchSuggestionsNotification.enable;"
                    accesskey="&urlbar.searchSuggestionsNotification.enable.accesskey;"
                    onclick="document.getBindingParent(this).dismissSearchSuggestionsNotification(true);"/>
      </xul:hbox>
      <xul:richlistbox anonid="richlistbox" class="autocomplete-richlistbox"
                       flex="1"/>
      <xul:hbox anonid="footer">
        <children/>
      </xul:hbox>
    </content>

    <implementation>
      <field name="_maxResults">0</field>

      <field name="_bundle" readonly="true">
        Cc["@mozilla.org/intl/stringbundle;1"].
          getService(Ci.nsIStringBundleService).
          createBundle("chrome://browser/locale/places/places.properties");
      </field>

      <field name="searchSuggestionsNotification" readonly="true">
        document.getAnonymousElementByAttribute(
          this, "anonid", "search-suggestions-notification"
        );
      </field>

      <field name="footer" readonly="true">
        document.getAnonymousElementByAttribute(this, "anonid", "footer");
      </field>

      <method name="openSearchSuggestionsNotificationLearnMoreURL">
        <body><![CDATA[
        let url = Services.urlFormatter.formatURL(
          Services.prefs.getCharPref("app.support.baseURL") + "suggestions"
        );
        openUILinkIn(url, "tab");
        ]]></body>
      </method>

      <method name="dismissSearchSuggestionsNotification">
        <parameter name="enableSuggestions"/>
        <body><![CDATA[
          // Make sure the urlbar is focused.  It won't be, for example, if the
          // user used an accesskey to make an opt-in choice.  mIgnoreFocus
          // prevents the text from being selected.
          this.input.mIgnoreFocus = true;
          this.input.focus();
          this.input.mIgnoreFocus = false;

          Services.prefs.setBoolPref(
            "browser.urlbar.suggest.searches", enableSuggestions
          );
          Services.prefs.setBoolPref(
            "browser.urlbar.userMadeSearchSuggestionsChoice", true
          );
          // The input's pref observer will now hide the notification.
        ]]></body>
      </method>

      <method name="getNextIndex">
        <parameter name="reverse"/>
        <parameter name="amount"/>
        <parameter name="index"/>
        <parameter name="maxRow"/>
        <body><![CDATA[
          if (maxRow < 0)
            return -1;

          let newIndex = index + (reverse ? -1 : 1) * amount;

          // We only want to wrap if navigation is in any direction by one item,
          // otherwise we clamp to one end of the list.
          // ie, hitting page-down will only cause is to wrap if we're already
          // at one end of the list.

          // Allow the selection to be removed if the first result is not a
          // heuristic result.
          if (!this._isFirstResultHeuristic) {
            if (reverse && index == -1 || newIndex > maxRow && index != maxRow)
              newIndex = maxRow;
            else if (!reverse && index == -1 || newIndex < 0 && index != 0)
              newIndex = 0;

            if (newIndex < 0 && index == 0 || newIndex > maxRow && index == maxRow)
              newIndex = -1;

            return newIndex;
          }

          // Otherwise do not allow the selection to be removed.
          if (newIndex < 0) {
            newIndex = index > 0 ? 0 : maxRow;
          } else if (newIndex > maxRow) {
            newIndex = index < maxRow ? maxRow : 0;
          }
          return newIndex;
        ]]></body>
      </method>

      <property name="_isFirstResultHeuristic" readonly="true">
        <getter>
          <![CDATA[
            // The popup usually has a special "heuristic" first result (added
            // by UnifiedComplete.js) that is automatically selected when the
            // popup opens.
            return this.input.mController.matchCount > 0 &&
                   this.input.mController
                             .getStyleAt(0)
                             .split(/\s+/).indexOf("heuristic") > 0;
          ]]>
        </getter>
      </property>

      <property name="maxResults" readonly="true">
        <getter>
          <![CDATA[
            if (!this._maxResults) {
              var prefService =
                Components.classes["@mozilla.org/preferences-service;1"]
                          .getService(Components.interfaces.nsIPrefBranch);
              this._maxResults = prefService.getIntPref("browser.urlbar.maxRichResults");
            }
            return this._maxResults;
          ]]>
        </getter>
      </property>

      <method name="openAutocompletePopup">
        <parameter name="aInput"/>
        <parameter name="aElement"/>
        <body>
          <![CDATA[
          // initially the panel is hidden
          // to avoid impacting startup / new window performance
          aInput.popup.hidden = false;

          if (aInput.shouldShowSearchSuggestionsNotification) {
            this._showSearchSuggestionsNotification();
          }

          this._openAutocompletePopup(aInput, aElement);
          ]]>
        </body>
      </method>

      <method name="_openAutocompletePopup">
        <parameter name="aInput"/>
        <parameter name="aElement"/>
        <body><![CDATA[
          if (this.mPopupOpen) {
            return;
          }

          this.mInput = aInput;
          this.selectedIndex = -1;
          this.view = aInput.controller.QueryInterface(Components.interfaces.nsITreeView);
          this.invalidate();
		  
		  var width = 300;
		  
		  try{
			width = document.getElementById("urlbar").getBoundingClientRect().width+2;
		  } catch(e){}

          this.setAttribute("width", width);

          this.openPopup(aElement, "after_start", -1, -1, false, false);
        ]]></body>
      </method>

      <method name="_updateFooterVisibility">
        <body>
          <![CDATA[
          this.footer.collapsed = this._matchCount == 0;
          ]]>
        </body>
      </method>

      <method name="_showSearchSuggestionsNotification">
        <parameter name="aInput"/>
        <parameter name="aElement"/>
        <body>
          <![CDATA[
          // With the notification shown, the listbox's height can sometimes be
          // too small when it's flexed, as it normally is.  Also, it can start
          // out slightly scrolled down.  Both problems appear together, most
          // often when the popup is very narrow and the notification's text
          // must wrap.  Work around them by removing the flex.
          //
          // But without flexing the listbox, the listbox's height animation
          // sometimes fails to complete, leaving the popup too tall.  Work
          // around that problem by disabling the listbox animation.
          this.richlistbox.flex = 0;
          this.setAttribute("dontanimate", "true");

          this.classList.add("showSearchSuggestionsNotification");
          this._updateFooterVisibility();

          // This event allows accessibility APIs to see the notification.
          if (!this.popupOpen) {
            let event = document.createEvent("Events");
            event.initEvent("AlertActive", true, true);
            this.searchSuggestionsNotification.dispatchEvent(event);
          }
          ]]>
        </body>
      </method>

      <method name="searchSuggestionsNotificationWasDismissed">
        <parameter name="enableSuggestions"/>
        <body>
          <![CDATA[
          if (!this.popupOpen) {
            this._hideSearchSuggestionsNotification();
            return;
          }
          this._hideSearchSuggestionsNotificationWithAnimation().then(() => {
            if (enableSuggestions && this.input.textValue) {
              // Start a new search so that suggestions appear immediately.
              this.input.controller.startSearch(this.input.textValue);
            }
          });
          ]]>
        </body>
      </method>

      <method name="_hideSearchSuggestionsNotification">
        <body>
          <![CDATA[
          this.classList.remove("showSearchSuggestionsNotification");
          this.richlistbox.flex = 1;
          this.removeAttribute("dontanimate");
          if (this._matchCount) {
            // Update popup height.
            this._invalidate();
          } else {
            this.closePopup();
          }
          ]]>
        </body>
      </method>

      <method name="_hideSearchSuggestionsNotificationWithAnimation">
        <body>
          <![CDATA[
          return new Promise(resolve => {
            let notificationHeight = this.searchSuggestionsNotification
                                         .getBoundingClientRect()
                                         .height;
            this.searchSuggestionsNotification.style.marginTop =
              "-" + notificationHeight + "px";

            let popupHeightPx =
              (this.getBoundingClientRect().height - notificationHeight) + "px";
            this.style.height = popupHeightPx;

            let onTransitionEnd = () => {
              this.removeEventListener("transitionend", onTransitionEnd, true);
              this.searchSuggestionsNotification.style.marginTop = "0px";
              this.style.removeProperty("height");
              this._hideSearchSuggestionsNotification();
              resolve();
            };
            this.addEventListener("transitionend", onTransitionEnd, true);
          });
          ]]>
        </body>
      </method>

      <method name="onPopupClick">
        <parameter name="aEvent"/>
        <body>
          <![CDATA[
          // Ignore right-clicks
          if (aEvent.button == 2)
            return;

          var controller = this.view.QueryInterface(Components.interfaces.nsIAutoCompleteController);

          // Check for unmodified left-click, and use default behavior
          if (aEvent.button == 0 && !aEvent.shiftKey && !aEvent.ctrlKey &&
              !aEvent.altKey && !aEvent.metaKey) {
            controller.handleEnter(true);
            return;
          }

          // Check for middle-click or modified clicks on the URL bar
          if (gURLBar && this.mInput == gURLBar) {
            var url = controller.getValueAt(this.selectedIndex);
            var options = {};

            // close the autocomplete popup and revert the entered address
            this.closePopup();
            controller.handleEscape();

            // Check if this is meant to be an action
            let action = this.mInput._parseActionUrl(url);
            if (action) {
              // TODO (bug 1054816): Centralise the implementation of actions
              // into a JS module.
              switch (action.type) {
                case "switchtab": // Fall through.
                case "keyword": // Fall through.
                case "visiturl": {
                  url = action.params.url;
                  break;
                }
                case "searchengine": {
                  [url, options.postData] =
                    this.input._parseAndRecordSearchEngineAction(action);
                  break;
                }
                default: {
                  return;
                }
              }
            }

            // respect the usual clicking subtleties
            openUILink(url, aEvent, options);
          }
        ]]>
        </body>
      </method>

      <method name="createResultLabel">
        <parameter name="item"/>
        <parameter name="proposedLabel"/>
        <body>
          <![CDATA[
            let parts = [proposedLabel];

            let action = this.mInput._parseActionUrl(item.getAttribute("url"));
            if (action) {
              switch (action.type) {
              case "searchengine":
                parts = [
                  action.params.searchSuggestion || action.params.searchQuery,
                  action.params.engineName,
                ];
                break;
              case "switchtab":
              case "remotetab":
                parts = [
                  item.getAttribute("title"),
                  item.getAttribute("displayurl"),
                ];
                break;
              }
            }

            let types = item.getAttribute("type").split(/\s+/);
            let type = types.find(type => type != "action" && type != "heuristic");
            try {
              // Some types intentionally do not map to strings, which is not
              // an error.
              parts.push(this._bundle.GetStringFromName(type + "ResultLabel"));
            } catch (e) {}

            return parts.filter(str => str).join(" ");
          ]]>
        </body>
      </method>

      <method name="onResultsAdded">
        <body>
          <![CDATA[
            if (!Services.prefs.getBoolPref("browser.urlbar.unifiedcomplete"))
              return;

            // If nothing is selected yet, select the first result if it is a
            // pre-selected "heuristic" result.  (See UnifiedComplete.js.)
            if (this.selectedIndex == -1 && this._isFirstResultHeuristic) {
              // Don't handle this as a user-initiated action.
              this._ignoreNextSelect = true;

              // Don't fire DOMMenuItemActive so that screen readers still see
              // the input as being focused.
              this.richlistbox.suppressMenuItemEvent = true;

              this.selectedIndex = 0;
              this.richlistbox.suppressMenuItemEvent = false;
              this._ignoreNextSelect = false;
            }

            this.input.gotResultForCurrentQuery = true;
            if (this.input.handleEnterWhenGotResult) {
              this.input.handleEnterWhenGotResult = false;
              this.input.mController.handleEnter(false);
            }
          ]]>
        </body>
      </method>

    </implementation>
    <handlers>

      <handler event="mousedown"><![CDATA[
        // Required to make the xul:label.text-link elements in the search
        // suggestions notification work correctly when clicked on Linux.
        // This is copied from the mousedown handler in
        // browser-search-autocomplete-result-popup, which apparently had a
        // similar problem.
        event.preventDefault();
      ]]></handler>

    </handlers>
  </binding>

  <binding id="autocomplete-richlistitem" extends="chrome://global/content/bindings/richlistbox.xml#richlistitem">

    <content align="start"
             onoverflow="this._onOverflow();"
             onunderflow="this._onUnderflow();">
      <xul:hbox>
		  <xul:image anonid="type-icon"
					 class="ac-type-icon"
					 xbl:inherits="selected,current"/>
		  <xul:image anonid="site-icon"
					 class="ac-site-icon"
					 xbl:inherits="src=image,selected"/>
		  <xul:hbox class="ac-title"
					align="start"
					xbl:inherits="selected">
			<xul:description class="ac-text-overflow-container">
			  <xul:description anonid="title-text"
							   class="ac-title-text"
							   xbl:inherits="selected"/>
			</xul:description>
		  </xul:hbox>
		  <xul:hbox anonid="tags"
					class="ac-tags"
					align="start"
					xbl:inherits="selected">
			<xul:description class="ac-text-overflow-container">
			  <xul:description anonid="tags-text"
							   class="ac-tags-text"
							   xbl:inherits="selected"/>
			</xul:description>
		  </xul:hbox>
	  </xul:hbox>
	  <xul:hbox>
		  <xul:hbox anonid="separator"
					class="ac-separator"
					align="start"
					xbl:inherits="selected,actiontype">
			<xul:description class="ac-separator-text">—</xul:description>
		  </xul:hbox>
		  <xul:hbox class="ac-url"
					align="start"
					xbl:inherits="selected,actiontype">
			<xul:description class="ac-text-overflow-container">
			  <xul:description anonid="url-text"
							   class="ac-url-text"
							   xbl:inherits="selected"/>
			</xul:description>
		  </xul:hbox>
		  <xul:hbox class="ac-action"
					align="start"
					xbl:inherits="selected,actiontype">
			<xul:description class="ac-text-overflow-container">
			  <xul:description anonid="action-text"
							   class="ac-action-text"
							   xbl:inherits="selected"/>
			</xul:description>
		  </xul:hbox>
	  </xul:hbox>
    </content>

    <implementation implements="nsIDOMXULSelectControlItemElement">
      <constructor>
        <![CDATA[
          this._typeIcon = document.getAnonymousElementByAttribute(
            this, "anonid", "type-icon"
          );
          this._siteIcon = document.getAnonymousElementByAttribute(
            this, "anonid", "site-icon"
          );
          this._titleText = document.getAnonymousElementByAttribute(
            this, "anonid", "title-text"
          );
          this._tags = document.getAnonymousElementByAttribute(
            this, "anonid", "tags"
          );
          this._tagsText = document.getAnonymousElementByAttribute(
            this, "anonid", "tags-text"
          );
          this._separator = document.getAnonymousElementByAttribute(
            this, "anonid", "separator"
          );
          this._urlText = document.getAnonymousElementByAttribute(
            this, "anonid", "url-text"
          );
          this._actionText = document.getAnonymousElementByAttribute(
            this, "anonid", "action-text"
          );
          this._adjustAcItem();
        ]]>
      </constructor>

      <property name="label" readonly="true">
        <getter>
          <![CDATA[
            // This property is a string that is read aloud by screen readers,
            // so it must not contain anything that should not be user-facing.

            let parts = [
              this.getAttribute("title"),
              this.getAttribute("displayurl"),
            ];
            let label = parts.filter(str => str).join(" ")

            // allow consumers that have extended popups to override
            // the label values for the richlistitems
            let panel = this.parentNode.parentNode;
            if (panel.createResultLabel) {
              return panel.createResultLabel(this, label);
            }

            return label;
          ]]>
        </getter>
      </property>

      <property name="_stringBundle">
        <getter><![CDATA[
          if (!this.__stringBundle) {
            this.__stringBundle = Services.strings.createBundle("chrome://global/locale/autocomplete.properties");
          }
          return this.__stringBundle;
        ]]></getter>
      </property>

      <field name="_boundaryCutoff">null</field>

      <property name="boundaryCutoff" readonly="true">
        <getter>
          <![CDATA[
          if (!this._boundaryCutoff) {
            this._boundaryCutoff =
              Components.classes["@mozilla.org/preferences-service;1"].
              getService(Components.interfaces.nsIPrefBranch).
              getIntPref("toolkit.autocomplete.richBoundaryCutoff");
          }
          return this._boundaryCutoff;
          ]]>
        </getter>
      </property>

      <field name="_inOverflow">false</field>

      <method name="_onOverflow">
        <body>
          <![CDATA[
          this._inOverflow = true;
          this._handleOverflow();
          ]]>
        </body>
      </method>

      <method name="_onUnderflow">
        <body>
          <![CDATA[
          this._inOverflow = false;
          this._handleOverflow();
          ]]>
        </body>
      </method>

      <method name="_getBoundaryIndices">
        <parameter name="aText"/>
        <parameter name="aSearchTokens"/>
        <body>
          <![CDATA[
          // Short circuit for empty search ([""] == "")
          if (aSearchTokens == "")
            return [0, aText.length];

          // Find which regions of text match the search terms
          let regions = [];
          for (let search of Array.prototype.slice.call(aSearchTokens)) {
            let matchIndex = -1;
            let searchLen = search.length;

            // Find all matches of the search terms, but stop early for perf
            let lowerText = aText.substr(0, this.boundaryCutoff).toLowerCase();
            while ((matchIndex = lowerText.indexOf(search, matchIndex + 1)) >= 0) {
              regions.push([matchIndex, matchIndex + searchLen]);
            }
          }

          // Sort the regions by start position then end position
          regions = regions.sort((a, b) => {
            let start = a[0] - b[0];
            return (start == 0) ? a[1] - b[1] : start;
          });

          // Generate the boundary indices from each region
          let start = 0;
          let end = 0;
          let boundaries = [];
          let len = regions.length;
          for (let i = 0; i < len; i++) {
            // We have a new boundary if the start of the next is past the end
            let region = regions[i];
            if (region[0] > end) {
              // First index is the beginning of match
              boundaries.push(start);
              // Second index is the beginning of non-match
              boundaries.push(end);

              // Track the new region now that we've stored the previous one
              start = region[0];
            }

            // Push back the end index for the current or new region
            end = Math.max(end, region[1]);
          }

          // Add the last region
          boundaries.push(start);
          boundaries.push(end);

          // Put on the end boundary if necessary
          if (end < aText.length)
            boundaries.push(aText.length);

          // Skip the first item because it's always 0
          return boundaries.slice(1);
          ]]>
        </body>
      </method>

      <method name="_getSearchTokens">
        <parameter name="aSearch"/>
        <body>
          <![CDATA[
          let search = aSearch.toLowerCase();
          return search.split(/\s+/);
          ]]>
        </body>
      </method>

      <method name="_setUpDescription">
        <parameter name="aDescriptionElement"/>
        <parameter name="aText"/>
        <parameter name="aNoEmphasis"/>
        <body>
          <![CDATA[
          // Get rid of all previous text
          while (aDescriptionElement.hasChildNodes())
            aDescriptionElement.removeChild(aDescriptionElement.firstChild);

          // If aNoEmphasis is specified, don't add any emphasis
          if (aNoEmphasis) {
            aDescriptionElement.appendChild(document.createTextNode(aText));
            return;
          }

          // Get the indices that separate match and non-match text
          let search = this.getAttribute("text");
          let tokens = this._getSearchTokens(search);
          let indices = this._getBoundaryIndices(aText, tokens);

          this._appendDescriptionSpans(indices, aText, aDescriptionElement,
                                       aDescriptionElement);
          ]]>
        </body>
      </method>

      <method name="_appendDescriptionSpans">
        <parameter name="indices"/>
        <parameter name="text"/>
        <parameter name="spansParentElement"/>
        <parameter name="descriptionElement"/>
        <body>
          <![CDATA[
          let next;
          let start = 0;
          let len = indices.length;
          // Even indexed boundaries are matches, so skip the 0th if it's empty
          for (let i = indices[0] == 0 ? 1 : 0; i < len; i++) {
            next = indices[i];
            let spanText = text.substr(start, next - start);
            start = next;

            if (i % 2 == 0) {
              // Emphasize the text for even indices
              let span = spansParentElement.appendChild(
                document.createElementNS("http://www.w3.org/1999/xhtml", "span"));
              this._setUpEmphasisSpan(span, descriptionElement);
              span.textContent = spanText;
            } else {
              // Otherwise, it's plain text
              spansParentElement.appendChild(document.createTextNode(spanText));
            }
          }
          ]]>
        </body>
      </method>

      <method name="_setUpTags">
        <parameter name="tags"/>
        <body>
          <![CDATA[
          while (this._tagsText.hasChildNodes()) {
            this._tagsText.firstChild.remove();
          }

          let anyTagsMatch = false;

          // Include only tags that match the search string.
          for (let tag of tags) {
            // Check if the tag matches the search string.
            let search = this.getAttribute("text");
            let tokens = this._getSearchTokens(search);
            let indices = this._getBoundaryIndices(tag, tokens);

            if (indices.length == 2 &&
                indices[0] == 0 &&
                indices[1] == tag.length) {
              // The tag doesn't match the search string, so don't include it.
              continue;
            }

            anyTagsMatch = true;

            let tagSpan =
              document.createElementNS("http://www.w3.org/1999/xhtml", "span");
            tagSpan.classList.add("ac-tag");
            this._tagsText.appendChild(tagSpan);

            this._appendDescriptionSpans(indices, tag, tagSpan, this._tagsText);
          }

          return anyTagsMatch;
          ]]>
        </body>
      </method>

      <method name="_setUpEmphasisSpan">
        <parameter name="aSpan"/>
        <parameter name="aDescriptionElement"/>
        <body>
          <![CDATA[
          aSpan.classList.add("ac-emphasize-text");
          switch (aDescriptionElement) {
            case this._titleText:
              aSpan.classList.add("ac-emphasize-text-title");
              break;
            case this._tagsText:
              aSpan.classList.add("ac-emphasize-text-tag");
              break;
            case this._urlText:
              aSpan.classList.add("ac-emphasize-text-url");
              break;
            case this._actionText:
              aSpan.classList.add("ac-emphasize-text-action");
              break;
          }
          ]]>
        </body>
      </method>

      <method name="_generateEmphasisPairs">
        <parameter name="aSourceString"/>
        <parameter name="aReplacements"/>
        <body>
          <![CDATA[
            let pairs = [];

            // Split on %S, %1$S, %2$S, etc. ie:
            //   "textA %S"
            //     becomes ["textA ", "%S"]
            //   "textA %1$S textB textC %2$S"
            //     becomes ["textA ", "%1$S", " textB textC ", "%2$S"]
            let parts = aSourceString.split(/(%(?:[0-9]+\$)?S)/);

            for (let part of parts) {
              // The above regex will actually give us an empty string at the
              // end - we don't want that, as we don't want to later generate an
              // empty text node for it.
              if (part.length === 0)
                continue;

              // Determine if this token is a replacement token or a normal text
              // token. If it is a replacement token, we want to extract the
              // numerical number. However, we still want to match on "$S".
              let match = part.match(/^%(?:([0-9]+)\$)?S$/);

              if (match) {
                // "%S" doesn't have a numerical number in it, but will always
                // be assumed to be 1. Furthermore, the input string specifies
                // these with a 1-based index, but we want a 0-based index.
                let index = (match[1] || 1) - 1;

                if (index >= 0 && index < aReplacements.length) {
                  pairs.push([...aReplacements[index]]);
                }
              } else {
                pairs.push([part]);
              }
            }

            return pairs;
          ]]>
        </body>
      </method>

      <method name="_setUpEmphasisedSections">
        <parameter name="aDescriptionElement"/>
        <parameter name="aTextPairs"/>
        <body>
          <![CDATA[
          // Get rid of all previous text
          while (aDescriptionElement.hasChildNodes())
            aDescriptionElement.firstChild.remove();

          for (let [text, emphasise] of aTextPairs) {
            if (emphasise) {
              let span = aDescriptionElement.appendChild(
                document.createElementNS("http://www.w3.org/1999/xhtml", "span"));
              span.textContent = text;
              switch(emphasise) {
                case "match":
                  this._setUpEmphasisSpan(span, aDescriptionElement);
                  break;
              }
            } else {
              aDescriptionElement.appendChild(document.createTextNode(text));
            }
          }
          ]]>
        </body>
      </method>

      <field name="_textToSubURI">null</field>
      <method name="_unescapeUrl">
        <parameter name="url"/>
        <body>
          <![CDATA[
          if (!this._textToSubURI) {
            this._textToSubURI =
              Components.classes["@mozilla.org/intl/texttosuburi;1"]
                        .getService(Components.interfaces.nsITextToSubURI);
          }
          return this._textToSubURI.unEscapeURIForUI("UTF-8", url);
          ]]>
        </body>
      </method>

      <method name="_adjustAcItem">
        <body>
          <![CDATA[
          this._removeMaxWidths();

          let title = this.getAttribute("title");

          let displayUrl;
          let originalUrl = this.getAttribute("url");
          let emphasiseUrl = true;

          let type = this.getAttribute("type");
          let types = new Set(type.split(/\s+/));
          let initialTypes = new Set(types);
          // Remove types that should ultimately not be in the `type` string.
          types.delete("action");
          types.delete("autofill");
          types.delete("heuristic");
          type = [...types][0] || "";

          let action;

          if (initialTypes.has("autofill")) {
            // Treat autofills as visiturl actions.
            action = {
              type: "visiturl",
              params: {
                url: originalUrl,
              },
            };
          }

          this.removeAttribute("actiontype");
          this.classList.remove("overridable-action");

          // If the type includes an action, set up the item appropriately.
          if (initialTypes.has("action") || action) {
            action = action || this._parseActionUrl(originalUrl);
            this.setAttribute("actiontype", action.type);

            if (action.type == "switchtab") {
              this.classList.add("overridable-action");
              displayUrl = this._unescapeUrl(action.params.url);
              let desc = this._stringBundle.GetStringFromName("switchToTab2");
              this._setUpDescription(this._actionText, desc, true);
            } else if (action.type == "remotetab") {
              displayUrl = this._unescapeUrl(action.params.url);
              let desc = action.params.deviceName;
              this._setUpDescription(this._actionText, desc, true);
            } else if (action.type == "searchengine") {
              emphasiseUrl = false;

              // The order here is not localizable, we default to appending
              // "- Search with Engine" to the search string, to be able to
              // properly generate emphasis pairs. That said, no localization
              // changed the order while it was possible, so doesn't look like
              // there's a strong need for that.
              let {engineName, searchSuggestion, searchQuery} = action.params;
              let engineStr =
                this._stringBundle.formatStringFromName("searchWithEngine",
                                                        [engineName], 1);
              this._setUpDescription(this._actionText, engineStr, true);

              // Make the title by generating an array of pairs and its
              // corresponding interpolation string (e.g., "%1$S") to pass to
              // _generateEmphasisPairs.
              let pairs;
              if (searchSuggestion) {
                // Check if the search query appears in the suggestion.  It may
                // not.  If it does, then emphasize the query in the suggestion
                // and otherwise just include the suggestion without emphasis.
                let idx = searchSuggestion.indexOf(searchQuery);
                if (idx >= 0) {
                  pairs = [
                    [searchSuggestion.substring(0, idx), ""],
                    [searchQuery, "match"],
                    [searchSuggestion.substring(idx + searchQuery.length), ""],
                  ];
                } else {
                  pairs = [
                    [searchSuggestion, ""],
                  ];
                }
              } else {
                pairs = [
                  [searchQuery, ""],
                ];
              }
              let interpStr = pairs.map((pair, i) => `%${i + 1}$S`).join("");
              title = this._generateEmphasisPairs(interpStr, pairs);

              // If this is a default search match, we remove the image so we
              // can style it ourselves with a generic search icon.
              // We don't do this when matching an aliased search engine,
              // because the icon helps with recognising which engine will be
              // used (when using the default engine, we don't need that
              // recognition).
              if (!action.params.alias && !initialTypes.has("favicon")) {
                this.removeAttribute("image");
              }
            } else if (action.type == "visiturl") {
              emphasiseUrl = false;
              displayUrl = this._unescapeUrl(action.params.url);
              title = displayUrl;
              let visitStr = this._stringBundle.GetStringFromName("visit");
              this._setUpDescription(this._actionText, visitStr, true);
            }
          }

          if (!displayUrl) {
            let input = this.parentNode.parentNode.input;
            let url = typeof(input.trimValue) == "function" ?
                      input.trimValue(originalUrl) :
                      originalUrl;
            displayUrl = this._unescapeUrl(url);
          }
          this.setAttribute("displayurl", displayUrl);

          // Show the domain as the title if we don't have a title.
          if (!title) {
            title = displayUrl;
            try {
              let uri = Services.io.newURI(originalUrl, null, null);
              // Not all valid URLs have a domain.
              if (uri.host)
                title = uri.host;
            } catch (e) {}
          }

          this._tags.setAttribute("empty", "true");

          if (type == "tag" || type == "bookmark-tag") {
            // The title is separated from the tags by an endash
            let tags;
            [, title, tags] = title.match(/^(.+) \u2013 (.+)$/);

            // Each tag is split by a comma in an undefined order, so sort it
            let sortedTags = tags.split(/\s*,\s*/).sort((a, b) => {
              return a.localeCompare(a);
            });

            let anyTagsMatch = this._setUpTags(sortedTags);
            if (anyTagsMatch) {
              this._tags.removeAttribute("empty");
            }
            if (type == "bookmark-tag") {
              type = "bookmark";
            }
          } else if (type == "keyword") {
            // Note that this is a moz-action with action.type == keyword.
            emphasiseUrl = false;
            let keywordArg = this.getAttribute("text").replace(/^[^\s]+\s*/, "");
            if (!keywordArg) {
              // Treat keyword searches without arguments as visiturl actions.
              type = "visiturl";
              this.setAttribute("actiontype", "visiturl");
              let visitStr = this._stringBundle.GetStringFromName("visit");
              this._setUpDescription(this._actionText, visitStr, true);
            } else {
              let pairs = [[title, ""], [keywordArg, "match"]];
              let interpStr =
                this._stringBundle.GetStringFromName("bookmarkKeywordSearch");
              title = this._generateEmphasisPairs(interpStr, pairs);
              // The action box will be visible since this is a moz-action, but
              // we want it to appear as if it were not visible, so set its text
              // to the empty string.
              this._setUpDescription(this._actionText, "", false);
            }
          }

          this._typeIcon.setAttribute("type", type);
          this._siteIcon.setAttribute("type", type);

          if (Array.isArray(title)) {
            this._setUpEmphasisedSections(this._titleText, title);
          } else {
            this._setUpDescription(this._titleText, title, false);
          }
          this._setUpDescription(this._urlText, displayUrl, !emphasiseUrl);

          if (this._inOverflow) {
            this._handleOverflow();
          }
          ]]>
        </body>
      </method>

      <method name="_removeMaxWidths">
        <body>
          <![CDATA[
          this._titleText.style.removeProperty("max-width");
          this._tagsText.style.removeProperty("max-width");
          this._urlText.style.removeProperty("max-width");
          this._actionText.style.removeProperty("max-width");
          ]]>
        </body>
      </method>

      <!-- This method truncates the displayed strings as necessary. -->
      <method name="_handleOverflow">
        <body><![CDATA[
          let itemRect = this.parentNode.getBoundingClientRect();
          let titleRect = this._titleText.getBoundingClientRect();
          let tagsRect = this._tagsText.getBoundingClientRect();
          let separatorRect = this._separator.getBoundingClientRect();
          let urlRect = this._urlText.getBoundingClientRect();
          let actionRect = this._actionText.getBoundingClientRect();
          let separatorURLActionWidth =
            separatorRect.width + Math.max(urlRect.width, actionRect.width);

          // Total width for the title and URL/action is the width of the item
          // minus the start of the title text minus a little extra padding.
          // This extra padding amount is basically arbitrary but keeps the text
          // from getting too close to the popup's edge.
          let extraPadding = 30;
          let dir =
            this.ownerDocument.defaultView.getComputedStyle(this).direction;
          let titleStart = dir == "rtl" ? itemRect.right - titleRect.right
                                        : titleRect.left - itemRect.left;
          let itemWidth = itemRect.width - titleStart - extraPadding;

          if (this._tags.hasAttribute("empty")) {
            // The tags box is not displayed in this case.
            tagsRect.width = 0;
          }

          let titleTagsWidth = titleRect.width + tagsRect.width;
          if (titleTagsWidth + separatorURLActionWidth > itemWidth) {
            // Title + tags + URL/action overflows the item width.

            // The percentage of the item width allocated to the title and tags.
            let titleTagsPct = 0.66;

            let titleTagsAvailable = itemWidth - separatorURLActionWidth;
            let titleTagsMaxWidth = Math.max(
              titleTagsAvailable,
              itemWidth * titleTagsPct
            );
            if (titleTagsWidth > titleTagsMaxWidth) {
              // Title + tags overflows the max title + tags width.

              // The percentage of the title + tags width allocated to the
              // title.
              let titlePct = 0.33;

              let titleAvailable = titleTagsMaxWidth - tagsRect.width;
              let titleMaxWidth = Math.max(
                titleAvailable,
                titleTagsMaxWidth * titlePct
              );
              let tagsAvailable = titleTagsMaxWidth - titleRect.width;
              let tagsMaxWidth = Math.max(
                tagsAvailable,
                titleTagsMaxWidth * (1 - titlePct)
              );
              this._titleText.style.maxWidth = titleMaxWidth + "px";
              this._tagsText.style.maxWidth = tagsMaxWidth + "px";
            }
            let urlActionMaxWidth = Math.max(
              itemWidth - titleTagsWidth,
              itemWidth * (1 - titleTagsPct)
            );
            urlActionMaxWidth -= separatorRect.width;
            this._urlText.style.maxWidth = urlActionMaxWidth + "px";
            this._actionText.style.maxWidth = urlActionMaxWidth + "px";
          }
        ]]></body>
      </method>

      <method name="handleOverUnderflow">
        <body>
          <![CDATA[
          this._removeMaxWidths();
          this._handleOverflow();
          ]]>
        </body>
      </method>

      <method name="_parseActionUrl">
        <parameter name="aUrl"/>
        <body><![CDATA[
          if (!aUrl.startsWith("moz-action:"))
            return null;

          // URL is in the format moz-action:ACTION,PARAMS
          // Where PARAMS is a JSON encoded object.
          let [, type, params] = aUrl.match(/^moz-action:([^,]+),(.*)$/);

          let action = {
            type: type,
          };

          try {
            action.params = JSON.parse(params);
            for (let key in action.params) {
              action.params[key] = decodeURIComponent(action.params[key]);
            }
          } catch (e) {
            // If this failed, we assume that params is not a JSON object, and
            // is instead just a flat string. This will happen when
            // UnifiedComplete is disabled - in which case, the param is always
            // a URL.
            action.params = {
              url: params,
            }
          }

          return action;
        ]]></body>
      </method>
    </implementation>
  </binding>
	  
</bindings>
