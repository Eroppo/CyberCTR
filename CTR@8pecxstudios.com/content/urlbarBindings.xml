<?xml version="1.0"?>

<!--
 Modified Firefox 48+ bindings offered in
 chrome://global/content/bindings/autocomplete.xml#autocomplete-rich-result-popup
 and
 chrome://browser/content/urlbarBindings.xml#urlbar-rich-result-popup
 to simulate pre-Fx48 look of location bars autocomplete popup.
 Removed all default comments to reduce file size. 
-->

<!DOCTYPE bindings [
<!ENTITY % notificationDTD SYSTEM "chrome://global/locale/notification.dtd">
%notificationDTD;
<!ENTITY % browserDTD SYSTEM "chrome://browser/locale/browser.dtd">
%browserDTD;
<!ENTITY % brandDTD SYSTEM "chrome://branding/locale/brand.dtd">
%brandDTD;
]>

<bindings id="urlbarBindings" xmlns="http://www.mozilla.org/xbl"
          xmlns:html="http://www.w3.org/1999/xhtml"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="autocomplete-richlistitem" extends="chrome://global/content/bindings/richlistbox.xml#richlistitem">

    <content align="start"
             onoverflow="this._onOverflow();"
             onunderflow="this._onUnderflow();">
	  <xul:hbox>
		  <xul:hbox align="center">
			  <xul:image anonid="site-icon"
						 class="ac-site-icon"
						 xbl:inherits="src=image,selected"/>
			  <xul:hbox class="ac-title"
						align="center"
						xbl:inherits="selected">
				<xul:description class="ac-text-overflow-container">
				  <xul:description anonid="title-text"
								   class="ac-title-text"
								   xbl:inherits="selected"/>
				</xul:description>

			  </xul:hbox>
			  <xul:hbox anonid="tags"
						class="ac-tags"
						align="center"
						xbl:inherits="selected">
				<xul:description class="ac-text-overflow-container">
				  <xul:description anonid="tags-text"
								   class="ac-tags-text"
								   xbl:inherits="selected"/>
				</xul:description>
			  </xul:hbox>
		  </xul:hbox>
		  <xul:spacer flex="1" id="ibox-spacer"/>
		  <xul:hbox align="end" id="ibox-box">
				<xul:image anonid="type-icon"
						 class="ac-type-icon"
						 xbl:inherits="selected,current"/>
		</xul:hbox>
	  </xul:hbox>
	  <xul:hbox align="center">
		  <xul:hbox anonid="separator"
					class="ac-separator"
					align="center"
					xbl:inherits="selected,actiontype">
			<xul:description class="ac-separator-text">â€”</xul:description>
		  </xul:hbox>
		  <xul:hbox class="ac-url"
					align="center"
					xbl:inherits="selected,actiontype">
			<xul:description class="ac-text-overflow-container">
			  <xul:description anonid="url-text"
							   class="ac-url-text"
							   xbl:inherits="selected"/>
			</xul:description>
		  </xul:hbox>
		  <xul:hbox class="ac-action"
					align="center"
					xbl:inherits="selected,actiontype">
			<xul:description class="ac-text-overflow-container">
			  <xul:description anonid="action-text"
							   class="ac-action-text"
							   xbl:inherits="selected"/>
			</xul:description>
		  </xul:hbox>
	  </xul:hbox>
    </content>

    <implementation implements="nsIDOMXULSelectControlItemElement">
      <constructor>
        <![CDATA[
          this._typeIcon = document.getAnonymousElementByAttribute(
            this, "anonid", "type-icon"
          );
          this._siteIcon = document.getAnonymousElementByAttribute(
            this, "anonid", "site-icon"
          );
          this._titleText = document.getAnonymousElementByAttribute(
            this, "anonid", "title-text"
          );
          this._tags = document.getAnonymousElementByAttribute(
            this, "anonid", "tags"
          );
          this._tagsText = document.getAnonymousElementByAttribute(
            this, "anonid", "tags-text"
          );
          this._separator = document.getAnonymousElementByAttribute(
            this, "anonid", "separator"
          );
          this._urlText = document.getAnonymousElementByAttribute(
            this, "anonid", "url-text"
          );
          this._actionText = document.getAnonymousElementByAttribute(
            this, "anonid", "action-text"
          );
          this._adjustAcItem();
        ]]>
      </constructor>

      <property name="label" readonly="true">
        <getter>
          <![CDATA[

            let parts = [
              this.getAttribute("title"),
              this.getAttribute("displayurl"),
            ];
            let label = parts.filter(str => str).join(" ")

            let panel = this.parentNode.parentNode;
            if (panel.createResultLabel) {
              return panel.createResultLabel(this, label);
            }

            return label;
          ]]>
        </getter>
      </property>

      <property name="_stringBundle">
        <getter><![CDATA[
          if (!this.__stringBundle) {
            this.__stringBundle = Services.strings.createBundle("chrome://global/locale/autocomplete.properties");
          }
          return this.__stringBundle;
        ]]></getter>
      </property>

      <field name="_boundaryCutoff">null</field>

      <property name="boundaryCutoff" readonly="true">
        <getter>
          <![CDATA[
          if (!this._boundaryCutoff) {
            this._boundaryCutoff =
              Components.classes["@mozilla.org/preferences-service;1"].
              getService(Components.interfaces.nsIPrefBranch).
              getIntPref("toolkit.autocomplete.richBoundaryCutoff");
          }
          return this._boundaryCutoff;
          ]]>
        </getter>
      </property>

      <field name="_inOverflow">false</field>

      <method name="_onOverflow">
        <body>
          <![CDATA[
          this._inOverflow = true;
          this._handleOverflow();
          ]]>
        </body>
      </method>

      <method name="_onUnderflow">
        <body>
          <![CDATA[
          this._inOverflow = false;
          this._handleOverflow();
          ]]>
        </body>
      </method>

      <method name="_getBoundaryIndices">
        <parameter name="aText"/>
        <parameter name="aSearchTokens"/>
        <body>
          <![CDATA[
          if (aSearchTokens == "")
            return [0, aText.length];

          let regions = [];
          for (let search of Array.prototype.slice.call(aSearchTokens)) {
            let matchIndex = -1;
            let searchLen = search.length;

            let lowerText = aText.substr(0, this.boundaryCutoff).toLowerCase();
            while ((matchIndex = lowerText.indexOf(search, matchIndex + 1)) >= 0) {
              regions.push([matchIndex, matchIndex + searchLen]);
            }
          }

          regions = regions.sort((a, b) => {
            let start = a[0] - b[0];
            return (start == 0) ? a[1] - b[1] : start;
          });

          let start = 0;
          let end = 0;
          let boundaries = [];
          let len = regions.length;
          for (let i = 0; i < len; i++) {

            let region = regions[i];
            if (region[0] > end) {

              boundaries.push(start);
              boundaries.push(end);

              start = region[0];
            }

            end = Math.max(end, region[1]);
          }

          boundaries.push(start);
          boundaries.push(end);

          if (end < aText.length)
            boundaries.push(aText.length);

          return boundaries.slice(1);
          ]]>
        </body>
      </method>

      <method name="_getSearchTokens">
        <parameter name="aSearch"/>
        <body>
          <![CDATA[
          let search = aSearch.toLowerCase();
          return search.split(/\s+/);
          ]]>
        </body>
      </method>

      <method name="_setUpDescription">
        <parameter name="aDescriptionElement"/>
        <parameter name="aText"/>
        <parameter name="aNoEmphasis"/>
        <body>
          <![CDATA[

          while (aDescriptionElement.hasChildNodes())
            aDescriptionElement.removeChild(aDescriptionElement.firstChild);

          if (aNoEmphasis) {
            aDescriptionElement.appendChild(document.createTextNode(aText));
            return;
          }

          let search = this.getAttribute("text");
          let tokens = this._getSearchTokens(search);
          let indices = this._getBoundaryIndices(aText, tokens);

          this._appendDescriptionSpans(indices, aText, aDescriptionElement,
                                       aDescriptionElement);
          ]]>
        </body>
      </method>

      <method name="_appendDescriptionSpans">
        <parameter name="indices"/>
        <parameter name="text"/>
        <parameter name="spansParentElement"/>
        <parameter name="descriptionElement"/>
        <body>
          <![CDATA[
          let next;
          let start = 0;
          let len = indices.length;

          for (let i = indices[0] == 0 ? 1 : 0; i < len; i++) {
            next = indices[i];
            let spanText = text.substr(start, next - start);
            start = next;

            if (i % 2 == 0) {

              let span = spansParentElement.appendChild(
                document.createElementNS("http://www.w3.org/1999/xhtml", "span"));
              this._setUpEmphasisSpan(span, descriptionElement);
              span.textContent = spanText;
            } else {

              spansParentElement.appendChild(document.createTextNode(spanText));
            }
          }
          ]]>
        </body>
      </method>

      <method name="_setUpTags">
        <parameter name="tags"/>
        <body>
          <![CDATA[
          while (this._tagsText.hasChildNodes()) {
            this._tagsText.firstChild.remove();
          }

          let anyTagsMatch = false;


          for (let tag of tags) {

            let search = this.getAttribute("text");
            let tokens = this._getSearchTokens(search);
            let indices = this._getBoundaryIndices(tag, tokens);

            if (indices.length == 2 &&
                indices[0] == 0 &&
                indices[1] == tag.length) {

              continue;
            }

            anyTagsMatch = true;

            let tagSpan =
              document.createElementNS("http://www.w3.org/1999/xhtml", "span");
            tagSpan.classList.add("ac-tag");
            this._tagsText.appendChild(tagSpan);

            this._appendDescriptionSpans(indices, tag, tagSpan, this._tagsText);
          }

          return anyTagsMatch;
          ]]>
        </body>
      </method>

      <method name="_setUpEmphasisSpan">
        <parameter name="aSpan"/>
        <parameter name="aDescriptionElement"/>
        <body>
          <![CDATA[
          aSpan.classList.add("ac-emphasize-text");
          switch (aDescriptionElement) {
            case this._titleText:
              aSpan.classList.add("ac-emphasize-text-title");
              break;
            case this._tagsText:
              aSpan.classList.add("ac-emphasize-text-tag");
              break;
            case this._urlText:
              aSpan.classList.add("ac-emphasize-text-url");
              break;
            case this._actionText:
              aSpan.classList.add("ac-emphasize-text-action");
              break;
          }
          ]]>
        </body>
      </method>

      <method name="_generateEmphasisPairs">
        <parameter name="aSourceString"/>
        <parameter name="aReplacements"/>
        <body>
          <![CDATA[
            let pairs = [];

            let parts = aSourceString.split(/(%(?:[0-9]+\$)?S)/);

            for (let part of parts) {
              if (part.length === 0)
                continue;

              let match = part.match(/^%(?:([0-9]+)\$)?S$/);

              if (match) {

                let index = (match[1] || 1) - 1;

                if (index >= 0 && index < aReplacements.length) {
                  pairs.push([...aReplacements[index]]);
                }
              } else {
                pairs.push([part]);
              }
            }

            return pairs;
          ]]>
        </body>
      </method>

      <method name="_setUpEmphasisedSections">
        <parameter name="aDescriptionElement"/>
        <parameter name="aTextPairs"/>
        <body>
          <![CDATA[

          while (aDescriptionElement.hasChildNodes())
            aDescriptionElement.firstChild.remove();

          for (let [text, emphasise] of aTextPairs) {
            if (emphasise) {
              let span = aDescriptionElement.appendChild(
                document.createElementNS("http://www.w3.org/1999/xhtml", "span"));
              span.textContent = text;
              switch(emphasise) {
                case "match":
                  this._setUpEmphasisSpan(span, aDescriptionElement);
                  break;
              }
            } else {
              aDescriptionElement.appendChild(document.createTextNode(text));
            }
          }
          ]]>
        </body>
      </method>

      <field name="_textToSubURI">null</field>
      <method name="_unescapeUrl">
        <parameter name="url"/>
        <body>
          <![CDATA[
          if (!this._textToSubURI) {
            this._textToSubURI =
              Components.classes["@mozilla.org/intl/texttosuburi;1"]
                        .getService(Components.interfaces.nsITextToSubURI);
          }
          return this._textToSubURI.unEscapeURIForUI("UTF-8", url);
          ]]>
        </body>
      </method>

      <method name="_adjustAcItem">
        <body>
          <![CDATA[
          this._removeMaxWidths();

          let title = this.getAttribute("title");

          let displayUrl;
          let originalUrl = this.getAttribute("url");
          let emphasiseUrl = true;

          let type = this.getAttribute("type");
          let types = new Set(type.split(/\s+/));
          let initialTypes = new Set(types);

          types.delete("action");
          types.delete("autofill");
          types.delete("heuristic");
          type = [...types][0] || "";

          let action;

          if (initialTypes.has("autofill")) {
            // Treat autofills as visiturl actions.
            action = {
              type: "visiturl",
              params: {
                url: originalUrl,
              },
            };
          }

          this.removeAttribute("actiontype");
          this.classList.remove("overridable-action");

          // If the type includes an action, set up the item appropriately.
          if (initialTypes.has("action") || action) {
            action = action || this._parseActionUrl(originalUrl);
            this.setAttribute("actiontype", action.type);

            if (action.type == "switchtab") {
              this.classList.add("overridable-action");
              displayUrl = this._unescapeUrl(action.params.url);
              let desc = this._stringBundle.GetStringFromName("switchToTab2");
              this._setUpDescription(this._actionText, desc, true);
            } else if (action.type == "remotetab") {
              displayUrl = this._unescapeUrl(action.params.url);
              let desc = action.params.deviceName;
              this._setUpDescription(this._actionText, desc, true);
            } else if (action.type == "searchengine") {
              emphasiseUrl = false;

              let {engineName, searchSuggestion, searchQuery} = action.params;
              let engineStr =
                this._stringBundle.formatStringFromName("searchWithEngine",
                                                        [engineName], 1);
              this._setUpDescription(this._actionText, engineStr, true);

              let pairs;
              if (searchSuggestion) {

                let idx = searchSuggestion.indexOf(searchQuery);
                if (idx >= 0) {
                  pairs = [
                    [searchSuggestion.substring(0, idx), ""],
                    [searchQuery, "match"],
                    [searchSuggestion.substring(idx + searchQuery.length), ""],
                  ];
                } else {
                  pairs = [
                    [searchSuggestion, ""],
                  ];
                }
              } else {
                pairs = [
                  [searchQuery, ""],
                ];
              }
              let interpStr = pairs.map((pair, i) => `%${i + 1}$S`).join("");
              title = this._generateEmphasisPairs(interpStr, pairs);

              if (!action.params.alias && !initialTypes.has("favicon")) {
                this.removeAttribute("image");
              }
            } else if (action.type == "visiturl") {
              emphasiseUrl = false;
              displayUrl = this._unescapeUrl(action.params.url);
              title = displayUrl;
              let visitStr = this._stringBundle.GetStringFromName("visit");
              this._setUpDescription(this._actionText, visitStr, true);
            }
          }

          if (!displayUrl) {
            let input = this.parentNode.parentNode.input;
            let url = typeof(input.trimValue) == "function" ?
                      input.trimValue(originalUrl) :
                      originalUrl;
            displayUrl = this._unescapeUrl(url);
          }
          this.setAttribute("displayurl", displayUrl);

          if (!title) {
            title = displayUrl;
            try {
              let uri = Services.io.newURI(originalUrl, null, null);
              // Not all valid URLs have a domain.
              if (uri.host)
                title = uri.host;
            } catch (e) {}
          }

          this._tags.setAttribute("empty", "true");

          if (type == "tag" || type == "bookmark-tag") {

            let tags;
            [, title, tags] = title.match(/^(.+) \u2013 (.+)$/);

            let sortedTags = tags.split(/\s*,\s*/).sort((a, b) => {
              return a.localeCompare(a);
            });

            let anyTagsMatch = this._setUpTags(sortedTags);
            if (anyTagsMatch) {
              this._tags.removeAttribute("empty");
            }
            if (type == "bookmark-tag") {
              type = "bookmark";
            }
          } else if (type == "keyword") {

            emphasiseUrl = false;
            let keywordArg = this.getAttribute("text").replace(/^[^\s]+\s*/, "");
            if (!keywordArg) {

              type = "visiturl";
              this.setAttribute("actiontype", "visiturl");
              let visitStr = this._stringBundle.GetStringFromName("visit");
              this._setUpDescription(this._actionText, visitStr, true);
            } else {
              let pairs = [[title, ""], [keywordArg, "match"]];
              let interpStr =
                this._stringBundle.GetStringFromName("bookmarkKeywordSearch");
              title = this._generateEmphasisPairs(interpStr, pairs);

              this._setUpDescription(this._actionText, "", false);
            }
          }

          this._typeIcon.setAttribute("type", type);
          this._siteIcon.setAttribute("type", type);

          if (Array.isArray(title)) {
            this._setUpEmphasisedSections(this._titleText, title);
          } else {
            this._setUpDescription(this._titleText, title, false);
          }
          this._setUpDescription(this._urlText, displayUrl, !emphasiseUrl);

          if (this._inOverflow) {
            this._handleOverflow();
          }
          ]]>
        </body>
      </method>

      <method name="_removeMaxWidths">
        <body>
          <![CDATA[
          this._titleText.style.removeProperty("max-width");
          this._tagsText.style.removeProperty("max-width");
          this._urlText.style.removeProperty("max-width");
          this._actionText.style.removeProperty("max-width");
          ]]>
        </body>
      </method>
	  
      <method name="adjustSiteIconStart">
        <parameter name="newStart"/>
        <body>
          <![CDATA[
          if (typeof(newStart) != "number") {
            this._typeIcon.style.removeProperty("-moz-margin-start");
            return true;
          }
          let rect = this._siteIcon.getBoundingClientRect();
          let dir = this.getAttribute("dir");
          let delta = dir == "rtl" ? rect.right - newStart
                                   : newStart - rect.left;
          let px = this._typeIcon.style.MozMarginStart;
          if (!px) {

            let style = window.getComputedStyle(this._typeIcon);
            px = dir == "rtl" ? style.marginRight : style.marginLeft;
          }
          let typeIconStart = Number(px.substr(0, px.length - 2));
          this._typeIcon.style.MozMarginStart = (typeIconStart + delta) + "px";
          return delta > 0;
          ]]>
        </body>
      </method>

      <!-- This method truncates the displayed strings as necessary. -->
      <method name="_handleOverflow">
        <body><![CDATA[
          let itemRect = this.parentNode.getBoundingClientRect();
          let titleRect = this._titleText.getBoundingClientRect();
          let tagsRect = this._tagsText.getBoundingClientRect();
          let separatorRect = this._separator.getBoundingClientRect();
          let urlRect = this._urlText.getBoundingClientRect();
          let actionRect = this._actionText.getBoundingClientRect();
          let separatorURLActionWidth =
            separatorRect.width + Math.max(urlRect.width, actionRect.width);

          // Total width for the title and URL/action is the width of the item
          // minus the start of the title text minus a little extra padding.
          // This extra padding amount is basically arbitrary but keeps the text
          // from getting too close to the popup's edge.
          let extraPadding = 30;
          let dir = this.getAttribute("dir");
          let titleStart = dir == "rtl" ? itemRect.right - titleRect.right
                                        : titleRect.left - itemRect.left;
          let itemWidth = itemRect.width - titleStart - extraPadding;

          if (this._tags.hasAttribute("empty")) {
            tagsRect.width = 0;
          }

          let titleTagsWidth = titleRect.width + tagsRect.width;
          if (titleTagsWidth + separatorURLActionWidth > itemWidth) {

            // The percentage of the item width allocated to the title and tags.
            let titleTagsPct = 0.66;

            let titleTagsAvailable = itemWidth - separatorURLActionWidth;
            let titleTagsMaxWidth = Math.max(
              titleTagsAvailable,
              itemWidth * titleTagsPct
            );
            if (titleTagsWidth > titleTagsMaxWidth) {
              let titlePct = 0.33;

              let titleAvailable = titleTagsMaxWidth - tagsRect.width;
              let titleMaxWidth = Math.max(
                titleAvailable,
                titleTagsMaxWidth * titlePct
              );
              let tagsAvailable = titleTagsMaxWidth - titleRect.width;
              let tagsMaxWidth = Math.max(
                tagsAvailable,
                titleTagsMaxWidth * (1 - titlePct)
              );
              this._titleText.style.maxWidth = (-62 + itemRect.width) + "px";
              this._tagsText.style.maxWidth = tagsMaxWidth + "px";
            }

            let titleMaxWidth = Math.max(
              (titleTagsMaxWidth - tagsRect.width),
              titleTagsMaxWidth * 0.33
            );

            this._urlText.style.maxWidth = (-62 + itemRect.width) + "px";
            this._actionText.style.maxWidth = (-62 + itemRect.width) + "px";
          }
        ]]></body>
      </method>

      <method name="handleOverUnderflow">
        <body>
          <![CDATA[
          this._removeMaxWidths();
          this._handleOverflow();
          ]]>
        </body>
      </method>

      <method name="_parseActionUrl">
        <parameter name="aUrl"/>
        <body><![CDATA[
          if (!aUrl.startsWith("moz-action:"))
            return null;

          let [, type, params] = aUrl.match(/^moz-action:([^,]+),(.*)$/);

          let action = {
            type: type,
          };

          try {
            action.params = JSON.parse(params);
            for (let key in action.params) {
              action.params[key] = decodeURIComponent(action.params[key]);
            }
          } catch (e) {
            action.params = {
              url: params,
            }
          }

          return action;
        ]]></body>
      </method>
    </implementation>
  </binding>	  
</bindings>
